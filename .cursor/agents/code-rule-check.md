---
name: code-rule-check
model: fast
description: 对修改的代码进行全面检查，确保符合项目规范和质量标准。
---

# 代码规则检查清单

对修改的代码进行全面检查，确保符合项目规范和质量标准。

## 1. 架构符合性检查

### 1.1 分层架构规范
- [ ] **API 层** (`api/v1/`): 仅处理 HTTP 请求/响应，不包含业务逻辑
- [ ] **服务层** (`services/`): 业务逻辑封装，可调用 models 和 db
- [ ] **模型层** (`models/`): 仅定义 SQLAlchemy ORM 模型，不包含业务逻辑
- [ ] **Schema 层** (`schemas/`): Pydantic 模型用于请求/响应验证
- [ ] **核心层** (`core/`): 核心类型、协议、枚举定义，无业务依赖

### 1.2 依赖方向检查
- [ ] 依赖方向正确：API → Services → Models → DB
- [ ] 无循环依赖：使用 `TYPE_CHECKING` 处理类型引用
- [ ] 无跨层调用：API 层不直接访问 models，services 不直接处理 HTTP

### 1.3 模块职责检查
- [ ] Agent 相关代码放在 `core/engine/` 或 `core/reasoning/`
- [ ] 工具相关代码放在 `tools/`
- [ ] 记忆相关代码放在 `core/memory/`
- [ ] 认证相关代码放在 `core/auth/`

## 2. 目录规范检查

### 2.1 文件命名规范
- [ ] 模块文件：`snake_case.py` (如 `user_service.py`)
- [ ] 类文件：一个文件一个主类，文件名与类名对应
- [ ] 测试文件：`test_<module>.py`，放在 `tests/` 对应目录

### 2.2 目录结构规范
- [ ] 新功能模块放在对应层级目录下
- [ ] 工具函数放在 `utils/`，业务逻辑不放在 `utils/`
- [ ] 共享类型定义放在 `core/types.py`
- [ ] 配置相关放在 `app/config.py` 或 `core/config.py`

### 2.3 导入规范
- [ ] 导入顺序：标准库 → 第三方库 → 本地模块
- [ ] 使用绝对导入：`from services.user import UserService`
- [ ] 避免 `from X import *`
- [ ] 类型检查时使用 `TYPE_CHECKING` 避免循环依赖

## 3. 软件工程最佳实践

### 3.1 类型安全
- [ ] 所有函数参数和返回值有完整类型注解
- [ ] 类属性有类型注解（使用 `Mapped[T]` 用于 SQLAlchemy）
- [ ] 通过 `pyright --strict` 类型检查
- [ ] 优先使用 `core/types.py` 中定义的类型（`Result`, `ToolProtocol` 等）

### 3.2 代码风格
- [ ] 符合 Ruff 配置（已在 `pyproject.toml`）
- [ ] 行长度不超过 100 字符
- [ ] 使用 `pathlib.Path` 而非 `os.path`
- [ ] 使用 f-string 而非 `.format()` 或 `%` 格式化

### 3.3 错误处理
- [ ] 使用 `Result[T, E]` 类型处理可能失败的操作
- [ ] 自定义异常继承自 `AIAgentError`（在 `exceptions.py`）
- [ ] API 层将业务异常转换为 HTTP 异常
- [ ] 异步操作有适当的异常处理

### 3.4 异步编程
- [ ] 数据库操作使用 `AsyncSession`
- [ ] I/O 操作使用 `async/await`
- [ ] 并发操作使用 `asyncio.gather()` 或 `asyncio.Semaphore`
- [ ] 流式响应使用 `AsyncGenerator`

### 3.5 文档与注释
- [ ] 模块有文档字符串说明用途
- [ ] 公共函数/方法有 Google 风格文档字符串
- [ ] 复杂逻辑有行内注释（解释"为什么"而非"是什么"）
- [ ] 类型注解足够清晰，减少注释需求

## 4. 设计合理性检查

### 4.1 避免过度设计
- [ ] 不引入不必要的抽象层
- [ ] 不创建"未来可能用到"的接口
- [ ] 不添加未使用的配置项
- [ ] 不实现超出当前需求的复杂模式

### 4.2 单一职责原则
- [ ] 每个函数只做一件事
- [ ] 每个类有明确的单一职责
- [ ] 模块职责边界清晰

### 4.3 开闭原则
- [ ] 对扩展开放：使用 Protocol 定义接口
- [ ] 对修改封闭：核心逻辑稳定，通过配置扩展

## 5. 代码复用检查

### 5.1 避免重复造轮子
- [ ] 优先使用 `core/types.py` 中的类型定义
- [ ] 复用 `services/` 中的业务服务
- [ ] 使用 `tools/` 中的工具而非重新实现
- [ ] 复用 `utils/` 中的工具函数

### 5.2 抽象复用
- [ ] 相似逻辑提取为公共函数/类
- [ ] 使用基类/Protocol 定义通用接口
- [ ] 配置化而非硬编码

### 5.3 依赖检查
- [ ] 检查是否有现成的第三方库可用
- [ ] 避免实现标准库已有的功能
- [ ] 优先使用项目已集成的库

## 6. 质量检查工具验证

### 6.1 静态检查
- [ ] 通过 `ruff check` 代码检查


### 6.2 测试覆盖
- [ ] 新功能有对应的单元测试
- [ ] 关键路径有集成测试
- [ ] 测试命名清晰：`test_<scenario>_<expected_result>`

## 7. 性能与安全

### 7.1 性能考虑
- [ ] 数据库查询使用索引字段
- [ ] 避免 N+1 查询问题
- [ ] 批量操作使用批量 API
- [ ] 异步操作正确使用 `await`

### 7.2 安全考虑
- [ ] 用户输入有验证（使用 Pydantic Schema）
- [ ] 敏感操作有权限检查
- [ ] 无 SQL 注入风险（使用 ORM 查询）
- [ ] 无路径遍历风险（使用 `pathlib` 规范化路径）

---

**检查原则**: 优先复用、符合架构、类型安全、避免过度设计

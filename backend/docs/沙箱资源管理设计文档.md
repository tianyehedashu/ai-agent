# 沙箱资源管理设计文档

## 1. 概述

沙箱资源管理系统负责管理 AI Agent 执行代码时所需的隔离运行环境，包括：

- **执行器管理**：Docker 容器的创建、复用和销毁
- **会话生命周期**：从创建到清理的全流程管理
- **资源控制**：内存、CPU、会话数量等限制
- **自动清理**：多种策略的过期资源回收

## 2. 系统架构

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           应用层 (FastAPI)                               │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                      │
│  │  Chat API   │  │  Agent API  │  │  Tool API   │                      │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘                      │
│         │                │                │                              │
│         └────────────────┼────────────────┘                              │
│                          ▼                                               │
├─────────────────────────────────────────────────────────────────────────┤
│                      SessionManager (单例)                               │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │  • 会话创建与复用                                                │    │
│  │  • 状态管理 (ACTIVE/IDLE/DISCONNECTED/COMPLETING)               │    │
│  │  • 用户/对话关联                                                 │    │
│  │  • 资源限制 (LRU 淘汰)                                          │    │
│  │  • 定期清理任务                                                  │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│                          │                                               │
│                          ▼                                               │
├─────────────────────────────────────────────────────────────────────────┤
│                       执行器层 (Executor)                                │
│  ┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐       │
│  │ SessionDocker    │  │ DockerExecutor   │  │ LocalExecutor    │       │
│  │ Executor         │  │ (无状态)          │  │ (仅开发)         │       │
│  │ (会话级容器)      │  │                   │  │                  │       │
│  └────────┬─────────┘  └────────┬─────────┘  └────────┬─────────┘       │
│           │                     │                     │                  │
│           └─────────────────────┼─────────────────────┘                  │
│                                 ▼                                        │
├─────────────────────────────────────────────────────────────────────────┤
│                        Docker Engine                                     │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                      │
│  │ session-xxx │  │ session-yyy │  │ session-zzz │  ...                 │
│  │ (容器)       │  │ (容器)       │  │ (容器)       │                      │
│  └─────────────┘  └─────────────┘  └─────────────┘                      │
└─────────────────────────────────────────────────────────────────────────┘
```

## 3. 核心组件

### 3.1 执行器 (Executor)

| 执行器 | 说明 | 适用场景 |
|--------|------|---------|
| `SessionDockerExecutor` | 会话级 Docker 容器，状态保持 | **生产环境推荐** |
| `DockerExecutor` | 无状态 Docker 容器，每次新建 | 一次性任务 |
| `LocalExecutor` | 本地直接执行，无隔离 | 仅开发调试 |

#### SessionDockerExecutor 特点

```python
# 会话容器保持运行，支持：
# 1. 状态保持 - 安装的包、创建的文件跨命令保留
# 2. 持久化卷 - 文件可保存到宿主机
# 3. 自动清理 - 多种策略自动回收

async with SessionDockerExecutor() as executor:
    await executor.execute_shell("pip install pandas")  # 安装保留
    await executor.execute_shell("python -c 'import pandas'")  # ✅ 正常工作
```

### 3.2 会话管理器 (SessionManager)

单例模式，负责所有会话的生命周期管理。

```python
from core.sandbox import SessionManager, CleanupReason

# 获取单例实例
manager = SessionManager.get_instance()

# 获取或创建会话（自动复用同一对话的容器）
session = await manager.get_or_create_session(
    user_id="user-123",
    conversation_id="conv-456",
)

# 执行命令
result = await session.executor.execute_shell("date")

# 状态管理
await manager.mark_session_complete(session.session_id)
await manager.mark_session_disconnected(session.session_id)
await manager.mark_session_reconnected(session.session_id)

# 主动结束
await manager.end_session(session.session_id, CleanupReason.USER_REQUEST)

# 获取统计信息
stats = manager.get_stats()
# {
#     "total_sessions": 5,
#     "total_users": 3,
#     "state_counts": {"active": 3, "idle": 2},
#     "policy": {...}
# }
```

### 3.3 会话状态机

```
                    ┌──────────────┐
                    │   CREATING   │
                    └──────┬───────┘
                           │ 创建完成
                           ▼
              ┌───────────────────────┐
              │        ACTIVE         │◄────────┐
              └───────────┬───────────┘         │
                          │                      │ 重连
              有活动 ─────┤                      │
                          │                      │
                          ▼                      │
              ┌───────────────────────┐         │
              │         IDLE          │         │
              └───────────┬───────────┘         │
                          │                      │
           连接断开 ──────┤                      │
                          ▼                      │
              ┌───────────────────────┐         │
              │     DISCONNECTED      │─────────┘
              └───────────┬───────────┘
                          │ 超时
                          ▼
              ┌───────────────────────┐
              │      COMPLETING       │ ← 任务完成
              └───────────┬───────────┘
                          │ 保留期过后
                          ▼
                      [清理容器]
```

## 4. 清理策略

### 4.1 清理场景

| 场景 | 触发条件 | 清理时机 | 原因代码 |
|------|---------|---------|---------|
| **用户主动结束** | 点击"结束对话" | 立即 | `USER_REQUEST` |
| **任务完成** | Agent 返回最终答案 | 可配置延迟 | `TASK_COMPLETE` |
| **空闲超时** | 无活动超过阈值 | 自动 | `IDLE_TIMEOUT` |
| **断开超时** | WebSocket 断开后未重连 | 自动 | `DISCONNECT_TIMEOUT` |
| **资源限制** | 达到最大会话数 | LRU 淘汰 | `RESOURCE_LIMIT` |
| **应用关闭** | 服务重启/停止 | 立即全部 | `APP_SHUTDOWN` |
| **异常错误** | 容器崩溃等 | 检测后清理 | `ERROR` |
| **孤儿容器** | 非正常退出残留 | 启动时清理 | `ORPHAN` |

### 4.2 清理优先级

```
高优先级（立即执行）
  │
  ├── USER_REQUEST (用户主动)
  ├── APP_SHUTDOWN (应用关闭)
  ├── RESOURCE_LIMIT (资源紧张)
  │
中优先级（定期检查）
  │
  ├── DISCONNECT_TIMEOUT (5分钟)
  ├── IDLE_TIMEOUT (30分钟)
  ├── TASK_COMPLETE (10分钟)
  │
低优先级（后台巡检）
  │
  └── ORPHAN (孤儿容器)
```

## 5. 配置说明

### 5.1 会话策略配置

```toml
# config/execution.toml

[sandbox.docker.session_policy]
# 空闲超时（秒）- 无活动后多久清理
idle_timeout = 1800              # 30 分钟

# 断开超时（秒）- 断开连接后等待重连时间
disconnect_timeout = 300         # 5 分钟

# 任务完成后保留时间（秒）- 方便用户查看结果
completion_retain = 600          # 10 分钟

# 最大会话时长（秒）- 硬性限制
max_session_duration = 7200      # 2 小时

# 每用户最大会话数
max_sessions_per_user = 3

# 全局最大会话数
max_total_sessions = 100

# 是否允许会话复用（同一对话复用容器）
allow_session_reuse = true
```

### 5.2 沙箱资源配置

```toml
# config/execution.toml

[sandbox]
mode = "docker"                  # docker | local | remote
timeout_seconds = 30             # 单次命令超时

[sandbox.resources]
memory_limit = "256m"            # 内存限制
cpu_limit = 1.0                  # CPU 核心数
disk_limit = "1g"                # 磁盘空间

[sandbox.network]
enabled = false                  # 默认禁用网络
allowed_hosts = []               # 白名单主机

[sandbox.security]
read_only_root = true            # 只读根文件系统
no_new_privileges = true         # 禁止提权

[sandbox.docker]
image = "ai-agent-sandbox:latest"  # 使用自定义镜像
session_enabled = true             # 启用会话模式
```

### 5.3 环境模板

开发环境（放宽限制）：
```toml
# config/environments/docker-dev.toml

[sandbox]
timeout_seconds = 120            # 更长超时

[sandbox.resources]
memory_limit = "512m"            # 更多内存
cpu_limit = 2.0                  # 更多 CPU

[sandbox.network]
enabled = true                   # 允许网络
allowed_hosts = ["pypi.org", "github.com"]
```

## 6. 资源保护机制

### 6.1 用户级限制

```
用户 A 的会话数 >= max_sessions_per_user (3)
         │
         ▼
    清理该用户最旧的会话（按 last_activity 排序）
         │
         ▼
    创建新会话
```

### 6.2 全局 LRU 淘汰

```
全局会话数 >= max_total_sessions (100)
         │
         ▼
    按 last_activity 排序所有会话
         │
         ▼
    优先清理：ERROR > IDLE > DISCONNECTED > COMPLETING
         │
         ▼
    创建新会话
```

### 6.3 定期巡检

```python
# 每 60 秒执行一次
async def _cleanup_loop():
    while running:
        await asyncio.sleep(60)
        
        for session in sessions:
            if should_cleanup(session):
                await remove_session(session)
```

## 7. 集成示例

### 7.1 Chat API 集成

```python
# api/v1/chat.py

@router.post("/sessions/{session_id}/chat")
async def chat(
    session_id: str,
    message: str,
    session_manager: SessionManager = Depends(get_session_manager),
):
    # 获取或创建会话
    session = await session_manager.get_or_create_session(
        user_id=current_user.id,
        conversation_id=session_id,
    )
    
    try:
        # 执行 Agent 任务
        result = await agent.run(message, executor=session.executor)
        
        # 任务完成，标记状态
        await session_manager.mark_session_complete(session.session_id)
        
        return result
    except Exception as e:
        # 错误处理
        await session_manager.end_session(
            session.session_id, 
            CleanupReason.ERROR
        )
        raise
```

### 7.2 WebSocket 断开处理

```python
# api/v1/chat.py

@router.websocket("/ws/{session_id}")
async def websocket_endpoint(websocket: WebSocket, session_id: str):
    await websocket.accept()
    
    session = await session_manager.get_or_create_session(
        conversation_id=session_id,
    )
    
    try:
        while True:
            data = await websocket.receive_text()
            # 更新活动时间
            await session_manager.update_session_activity(session.session_id)
            # 处理消息...
    except WebSocketDisconnect:
        # 标记断开，等待重连
        await session_manager.mark_session_disconnected(session.session_id)
```

### 7.3 用户主动结束

```python
@router.delete("/sessions/{session_id}")
async def end_session(
    session_id: str,
    session_manager: SessionManager = Depends(get_session_manager),
):
    await session_manager.end_session(session_id, CleanupReason.USER_REQUEST)
    return {"status": "ended"}
```

## 8. 监控与运维

### 8.1 统计接口

```python
@router.get("/admin/sessions/stats")
async def get_session_stats(
    session_manager: SessionManager = Depends(get_session_manager),
):
    return session_manager.get_stats()

# 返回示例：
# {
#     "total_sessions": 45,
#     "total_users": 23,
#     "state_counts": {
#         "active": 12,
#         "idle": 28,
#         "disconnected": 3,
#         "completing": 2
#     },
#     "policy": {
#         "idle_timeout": 1800,
#         "max_sessions_per_user": 3,
#         "max_total_sessions": 100
#     }
# }
```

### 8.2 Docker 命令

```bash
# 查看所有会话容器
docker ps -a --filter "name=session-"

# 手动清理所有会话容器（紧急情况）
docker rm -f $(docker ps -aq --filter "name=session-")

# 查看容器资源使用
docker stats --filter "name=session-"
```

### 8.3 日志

```
# 会话创建
INFO - Created session abc123 for user=user-1, conversation=conv-1

# 会话清理
INFO - Removed session abc123, reason=idle_timeout, duration=0:35:00, commands=15

# 定期清理
INFO - Periodic cleanup: removed 3 expired containers

# 资源限制触发
INFO - User user-1 reached session limit, cleaning oldest session
```

## 9. 最佳实践

### 9.1 开发环境

```toml
[sandbox.docker.session_policy]
idle_timeout = 3600              # 1小时（开发时更长）
max_sessions_per_user = 5        # 更多会话便于测试
```

### 9.2 生产环境

```toml
[sandbox.docker.session_policy]
idle_timeout = 1800              # 30分钟（节省资源）
disconnect_timeout = 120         # 2分钟（快速回收断开连接）
max_total_sessions = 200         # 根据服务器配置调整
```

### 9.3 高并发场景

```toml
[sandbox.docker.session_policy]
idle_timeout = 600               # 10分钟（激进回收）
max_sessions_per_user = 2        # 限制用户资源
max_total_sessions = 500         # 增加总量
allow_session_reuse = true       # 必须开启复用
```

## 10. 故障排查

### 10.1 容器泄漏

**症状**：`docker ps` 显示大量 `session-*` 容器

**排查**：
```bash
# 检查容器创建时间
docker ps -a --filter "name=session-" --format "{{.Names}}\t{{.CreatedAt}}"

# 检查应用日志中的清理记录
grep "Removed session" app.log
```

**解决**：
```bash
# 重启应用（会自动清理）
systemctl restart ai-agent

# 或手动清理
docker rm -f $(docker ps -aq --filter "name=session-")
```

### 10.2 会话无法创建

**症状**：`get_or_create_session` 抛出异常

**可能原因**：
1. Docker 服务未启动
2. 镜像不存在
3. 达到系统资源限制

**排查**：
```bash
# 检查 Docker 服务
docker info

# 检查镜像
docker images ai-agent-sandbox

# 检查系统资源
docker system df
```

### 10.3 命令执行超时

**症状**：所有命令返回 `timeout`

**可能原因**：
1. 容器已停止但状态未更新
2. Docker 守护进程无响应

**解决**：
```python
# 强制结束并重建会话
await session_manager.end_session(session_id, CleanupReason.ERROR)
session = await session_manager.get_or_create_session(...)
```

## 11. 版本历史

| 版本 | 日期 | 变更 |
|------|------|------|
| 1.0 | 2026-01-17 | 初始版本：会话管理、多策略清理、资源限制 |

## 12. 相关文档

- [执行环境配置设计文档](./执行环境配置设计文档.md)
- [AI-Agent系统架构设计文档](../AI-Agent系统架构设计文档.md)
- [Docker 沙箱镜像 README](../docker/sandbox/README.md)
